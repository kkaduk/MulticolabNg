package net.kaduk.infrastructure.grpc

import org.apache.pekko.actor.typed.{ActorRef, ActorSystem}
import org.apache.pekko.stream.scaladsl.Source
import org.apache.pekko.NotUsed
import org.apache.pekko.actor.typed.scaladsl.AskPattern.*
import org.apache.pekko.util.Timeout
import net.kaduk.agents.{BaseAgent, CoordinatorAgent}
import net.kaduk.domain.*
import scala.concurrent.{Future, ExecutionContext}
import scala.concurrent.duration.*

// Temporary case classes until protobuf generates them
case class ChatMessage(
  conversationId: String,
  content: String,
  role: String,
  metadata: Map[String, String] = Map.empty
)

case class ChatResponse(
  messageId: String,
  content: String,
  isComplete: Boolean,
  error: String = ""
)

case class AgentStatusRequest(agentId: String)
case class AgentStatusResponse(status: String, activeConversations: Int)

// Service trait (will be generated by protobuf plugin)
trait AgentService:
  def chat(in: Source[ChatMessage, NotUsed]): Source[ChatResponse, NotUsed]
  def getAgentStatus(in: AgentStatusRequest): Future[AgentStatusResponse]

class AgentServiceImpl(
  coordinatorRef: ActorRef[BaseAgent.Command]
)(using system: ActorSystem[?], ec: ExecutionContext) extends AgentService:

  override def chat(in: Source[ChatMessage, NotUsed]): Source[ChatResponse, NotUsed] =
    in.flatMapConcat: msg =>
      val context = ConversationContext(msg.conversationId)
      val domainMsg = Message(
        role = MessageRole.valueOf(msg.role),
        content = MessageContent(msg.content, msg.metadata),
        conversationId = msg.conversationId
      )
      
      Source.future(askCoordinator(domainMsg, context))
        .flatMapConcat(identity)
    
  private def askCoordinator(
    msg: Message,
    ctx: ConversationContext
  ): Future[Source[ChatResponse, NotUsed]] =
    given Timeout = 60.seconds
    
    coordinatorRef.ask[BaseAgent.Response]: replyTo =>
      BaseAgent.ProcessMessage(msg, ctx, replyTo)
    .map:
      case BaseAgent.ProcessedMessage(message, _) =>
        Source.single(ChatResponse(message.id, message.content.text, isComplete = true))
      case BaseAgent.ProcessingFailed(error, msgId) =>
        Source.single(ChatResponse(msgId, "", isComplete = true, error = error))
      case _ =>
        Source.single(ChatResponse("", "", isComplete = true, error = "Unknown response"))

  override def getAgentStatus(in: AgentStatusRequest): Future[AgentStatusResponse] =
    Future.successful(AgentStatusResponse("active", 0))

// Placeholder for gRPC handler (will be generated)
object AgentServiceHandler:
  def apply(impl: AgentServiceImpl)(using ActorSystem[?]): org.apache.pekko.http.scaladsl.model.HttpRequest => Future[org.apache.pekko.http.scaladsl.model.HttpResponse] =
    import org.apache.pekko.http.scaladsl.model.*
    _ => Future.successful(HttpResponse(StatusCodes.NotImplemented))